<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sandy的学习之路">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sandy的学习之路">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sandy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sandy的学习之路</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sandy的学习之路</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">39</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A14/" class="post-title-link" itemprop="url">Socket局域网通信4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 14:31:53" itemprop="dateCreated datePublished" datetime="2022-01-04T14:31:53+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 18:02:12" itemprop="dateModified" datetime="2022-01-05T18:02:12+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="网络编程Socket相关资料"><a href="#网络编程Socket相关资料" class="headerlink" title="网络编程Socket相关资料"></a>网络编程Socket相关资料</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34068198/article/details/92040607?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242.1&utm_relevant_index=3">Java Socket多线程异步通信</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sundh1981/p/13404891.html">网络编程Socket 异步发送接收</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuajiehe1234567/article/details/79173196">JAVA使用Socket进行异步通讯</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42489917/article/details/114257125">java 异步通信处理_java异步通信</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34068198/article/details/92040607?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242.1&utm_relevant_index=3">Java Socket多线程异步通信</a></p>
<h3 id="java多线程相关资料"><a href="#java多线程相关资料" class="headerlink" title="java多线程相关资料"></a>java多线程相关资料</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107479862">Java 多线程</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-multithreading.html">Java多线程-菜鸟</a></p>
<h3 id="ByteBuffer类："><a href="#ByteBuffer类：" class="headerlink" title="ByteBuffer类："></a>ByteBuffer类：</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/t000818/article/details/79023134">ByteBuffer详解</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xialong_927/article/details/81044759">JAVA NIO缓冲区(Buffer)——ByteBuffer常用方法详解</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22701869/article/details/107091427">ByteBuff常用方法，使用</a></p>
<h3 id="Socket高并发相关资料"><a href="#Socket高并发相关资料" class="headerlink" title="Socket高并发相关资料"></a>Socket高并发相关资料</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yueweimian/p/6262211.html"><strong>ServerSocketChannel实现多Selector高并发server</strong></a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nanlinghan/p/10130978.html">NIO高并发基础</a><br><a target="_blank" rel="noopener" href="https://my.oschina.net/enyo/blog/910100">Java高并发异步Socket编程</a></p>
<blockquote>
<p>NIO高并发是jdk1.4出现的新的流<br>NIO - New IO - 同步式非阻塞式IO<br>BIO - Blocking IO - 同步式阻塞式IO —UDP/TCP<br>AIO - AsynchronousIO - 异步式非阻塞IO - jdk1.8</p>
</blockquote>
<h4 id="java-nio提供的支持"><a href="#java-nio提供的支持" class="headerlink" title="java.nio提供的支持"></a>java.nio提供的支持</h4><ul>
<li>Channels<blockquote>
<p>通道是文件、socket之间的连接，支持非阻塞读取</p>
</blockquote>
</li>
<li>Buffers<blockquote>
<p>数组对象，可以被Channel直接读写</p>
</blockquote>
</li>
<li>Selectors<blockquote>
<p>负责筛选哪些Channel有IO事件</p>
</blockquote>
</li>
<li>SelectionKeys<blockquote>
<p>保存IO事件状态和绑定对象</p>
</blockquote>
</li>
</ul>
<h4 id="Log使用"><a href="#Log使用" class="headerlink" title="Log使用"></a>Log使用</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hun2014/articles/3851265.html">Apache通用日志工具commons-logging和Log4j使用总结</a></p>
<h4 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7b2f1fa616c6">不怕难之BlockingQueue及其实现</a></p>
<h5 id="E-take-方法"><a href="#E-take-方法" class="headerlink" title="E take()方法"></a>E take()方法</h5><p>take()方法可以得到队头的元素，在队列为空时会阻塞，直到队列中有元素可取。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/karlMa/p/11313330.html">延迟队列DelayQueue take()源码分析</a></p>
<h4 id="SocketChannel的socket-参数"><a href="#SocketChannel的socket-参数" class="headerlink" title="SocketChannel的socket()参数"></a>SocketChannel的socket()参数</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33853794/article/details/91973144">socket参数详解:TcpNoDelay</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket.setKeepAlive(<span class="keyword">true</span>);<span class="comment">//监视TCP连接是否有效</span></span><br><span class="line">socket.setTcpNoDelay(<span class="keyword">true</span>); <span class="comment">//套接字缓冲区是否关闭，以确保数据的及时传递</span></span><br></pre></td></tr></table></figure>
<p>注：TcpNoDelay=false，为启用nagle算法，也是默认值。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yhlx/articles/3640669.html">java socket nagle算法</a></p>
<h4 id="并发情况下的拆包粘包"><a href="#并发情况下的拆包粘包" class="headerlink" title="并发情况下的拆包粘包"></a>并发情况下的拆包粘包</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/scythe666/article/details/51996268">TCP粘包，拆包及解决方法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/songfeng-123-2251775"><strong>nio实现Socket长连接和心跳</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/universsky2015/article/details/105554297">Java 阻塞队列 BlockingQueue</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/guomeijuan916/article/details/8165165">ByteBuffer remaining 简介</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbtj_1216/article/details/53129588">java.nio.Buffer 中的 flip()方法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A13/" class="post-title-link" itemprop="url">Socket局域网通信3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 10:18:09" itemprop="dateCreated datePublished" datetime="2022-01-04T10:18:09+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 14:18:15" itemprop="dateModified" datetime="2022-01-05T14:18:15+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5c13ed1c709c?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">Java拆包粘包问题</a></p>
<h3 id="Java-NIO类"><a href="#Java-NIO类" class="headerlink" title="Java NIO类"></a>Java NIO类</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cold___play/article/details/106632505">ServerSocketChannel类API详解（一）</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">selector = Selector.open();  <span class="comment">//打开一个选择器</span></span><br><span class="line">        serverSocketChannel = ServerSocketChannel.open(); <span class="comment">//创建ServerSocketChannel类的实例</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);  <span class="comment">//非阻塞模式</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>)); <span class="comment">//将通道的套接字绑定到本地地址并侦听连接</span></span><br><span class="line">        selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<h4 id="channel-register-方法"><a href="#channel-register-方法" class="headerlink" title="channel.register()方法"></a>channel.register()方法</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lhxaiee123/article/details/76375338">SelectionKey详解</a></p>
<p><strong>Interest Set</strong><br>监听的Channel通道触发了一个事件意思是该事件已经就绪。<br>一个channel成功连接到另一个服务器称为”连接就绪”。<br>一个server socket channel准备号接收新进入的连接称为”接收就绪”。<br>一个有数据可读的通道可以说是”读就绪”。<br>一个等待写数据的通道可以说是”写就绪”。</p>
<p>这四种事件用SelectionKey的四个常量来表示：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<h4 id="Channel-accept"><a href="#Channel-accept" class="headerlink" title="Channel.accept()"></a>Channel.accept()</h4><p>非阻塞模式下，accept()方法在没有客户端连接时，返回null值。<br><img src="/2022/01/04/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A13/1.png"><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28758749/article/details/51214009?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&utm_relevant_index=2">Socket异常之Connection reset</a><br>客户端结束连接时，产生报错如上，暂时怀疑是accept()造成的。可以看一下：<a target="_blank" rel="noopener" href="https://blog.csdn.net/billluffy/article/details/78036998">SocketChannel—各种注意点</a>，其中提到</p>
<blockquote>
<p>关闭客户端，服务端会发生一个read事件，并且在read的时候抛出异常，来表示关闭</p>
</blockquote>
<h4 id="ByteBuffer类"><a href="#ByteBuffer类" class="headerlink" title="ByteBuffer类"></a>ByteBuffer类</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mrliuzhao/article/details/89453082">java.nio.ByteBuffer用法小结</a></p>
<h5 id="代码语句解析"><a href="#代码语句解析" class="headerlink" title="代码语句解析"></a>代码语句解析</h5><ul>
<li>创建大小为100的堆字节缓冲区<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36951116/article/details/87185240">补充：allocateDirect方法</a></li>
<li>从填充到释放状态的缓冲区翻转(将位置值设回 0)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheBuffer.flip();</span><br></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="http://blog.csdn.net/renyican/article/details/50504965?locationNum=2&fps=1">补充：Buffer类的详解</a></li>
<li>相对写，向position的位置写入一个byte，并将postion+1，为下次读写作准备<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.put(cacheBuffer);</span><br></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/JAYIT/p/8384476.html"><strong>ByteBuffer常用方法详解</strong></a></li>
<li>serverSocketChannel读取数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.read(byteBuffer);</span><br></pre></td></tr></table></figure></li>
<li>翻转，将一个处于存数据状态的缓冲区变为一个处于准备取数据的状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.flip();</span><br></pre></td></tr></table></figure></li>
<li>返回limit和position之间相对位置差<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.remaining()</span><br></pre></td></tr></table></figure></li>
<li>mark()对当前位置进行标记<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.mark();</span><br></pre></td></tr></table></figure></li>
<li>相对读，从position位置读取一个byte，并将position+1，为下次读写作准备<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.get(headByte);</span><br></pre></td></tr></table></figure></li>
<li>byteArray数组转换为int<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bodyLen = byteArrayToInt(headByte);</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5>总之ByteBuffer的基本用法就是：<br>初始化（allocate）–&gt; 写入数据（read / put）–&gt; 转换为写出模式（flip）–&gt; 写出数据（get）–&gt; 转换为写入模式（compact）–&gt; 写入数据（read / put）…</li>
</ul>
<h4 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h4><p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-iterator.html">Java Iterator(迭代器)</a><br>Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。<br>Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。</p>
<p>迭代器 it 的两个基本操作是 next 、hasNext 和 remove。<br>调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。<br>调用 it.hasNext() 用于检测集合中是否还有元素。<br>调用 it.remove() 将迭代器返回的元素删除。</p>
<h4 id="synchronized锁定对象"><a href="#synchronized锁定对象" class="headerlink" title="synchronized锁定对象"></a>synchronized锁定对象</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lukelook/p/9946065.html">synchronized的四种用法</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iter = keySet.iterator();<span class="comment">//获取迭代器</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    SelectionKey selectionKey = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (iter) &#123;</span><br><span class="line">        selectionKey = iter.next();  <span class="comment">//返回迭代器的下一个元素，并且更新迭代器的状态</span></span><br><span class="line">        iter.remove(); <span class="comment">//将迭代器返回的元素删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br></pre></td></tr></table></figure>
<p>给iter对象加了锁。这时，当一个线程访问iter对象时，其他试图访问iter对象的线程将会阻塞，直到该线程访问iter对象结束。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36951116/article/details/89340974">NIO 关于SocketChannel的isConnected与finishConnect区别</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A12/" class="post-title-link" itemprop="url">Socket局域网通信2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-30 17:24:37" itemprop="dateCreated datePublished" datetime="2021-12-30T17:24:37+08:00">2021-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-31 18:00:00" itemprop="dateModified" datetime="2021-12-31T18:00:00+08:00">2021-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/119850.htm">java 实现局域网文件传输的实例</a></p>
<h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><p><a target="_blank" rel="noopener" href="https://www.itcast.cn/news/20210628/1615185428.shtml">InetAddress类的常用方法与基本操作演示</a><br>在JDK中提供了一个与IP地址相关的InetAddress类，该类用于封装一个IP地址，并提供了一系列与IP地址相关的方法。<br>InetAddress类中的一些常用方法：</p>
<table>
    <tr>
        <th>方法声明</th>
        <th>功能描述</th>
    </tr>
    <tr>
        <td>InetAddress getByName(String host)</td>
        <td>获取给定主机名的的IP地址，host参数表示指定主机</td>
    </tr>
    <tr>
        <td>InetAddress getLocalHost()</td>
        <td>获取本地主机地址</td>
    </tr>
    <tr>
        <td>String getHostName()</td>
        <td>获取本地IP地址的主机名</td>
    </tr>
    <tr>
        <td>boolean isReachable(int timeout)</td>
        <td>判断在限定时间内指定的IP地址是否可以访问</td>
    </tr>
    <tr>
        <td>String getHostAddress()</td>
        <td>获取字符串格式的原始IP地址</td>
    </tr>
</table>

<h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44618862/article/details/98480120">网络编程（DatagramSocket &amp;&amp; DatagramPacket）</a></p>
<h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/4660570.html">Java网络编程之TCP通信</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41517936/article/details/81015711">Socket和ServerSocket的简单介绍及例子</a></p>
<h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>socket可以使一个应用从网络中读取和写入数据，不同计算机上的两个应用可以通过连接发送和接受字节流，当发送消息时，你需要知道对方的ip和端口，在java中，socket指的是java.net.Socket类。<br>一旦成功创建一个Socket类的实例，可以用它来发送和接收字节流，发送时调用getOutputStream方法获取一个java.io.OutputStream对象，接收远程对象发送来的信息可以调用getInputStream方法来返回一个java.io.InputStream对象。</p>
<h4 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h4><p>Socket类代表一个客户端套接字，即任何时候连接到一个远程服务器应用时构建所需的socket。现在，要实现一个服务器应用，需要不同的做法。服务器需随时待命，因为不知道客户端什么时候会发来请求，此时，我们需要使用ServerSocket，对应的是java.net.ServerSocket类。<br>ServerSocket与Socket不同，ServerSocket是等待客户端的请求，一旦获得一个连接请求，就创建一个Socket示例来与客户端进行通信。</p>
<h4 id="BufferedReader流"><a href="#BufferedReader流" class="headerlink" title="BufferedReader流"></a>BufferedReader流</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ai_bao_zi/article/details/81134801">JAVA基础知识之BufferedReader流</a></p>
<h4 id="BufferedWriter流"><a href="#BufferedWriter流" class="headerlink" title="BufferedWriter流"></a>BufferedWriter流</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ai_bao_zi/article/details/81187688">JAVA基础知识之BufferedWriter流</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43472877/article/details/104145859">BufferedWriter的newLine()方法</a></p>
<h4 id="socket长连接粘包拆包"><a href="#socket长连接粘包拆包" class="headerlink" title="socket长连接粘包拆包"></a>socket长连接粘包拆包</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hjing123/article/details/90710432">socket 长连接粘包拆包问题</a>：通过示例说明了长连接与简单的粘包拆包问题，虽然是跟web端相关的实例，值得参考。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97699272">Java详解：TCP粘包、拆包与通信协议</a>：对粘包拆包说明得很透彻，看完明白了粘包、拆包问题。<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5c13ed1c709c?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">java nio解决拆包粘包问题</a>：使用了NIO socket，但是关于拆包、粘包的具体方法写的很详细，<strong>多看看</strong>！</p>
<h4 id="ByteArrayOutputStream类"><a href="#ByteArrayOutputStream类" class="headerlink" title="ByteArrayOutputStream类"></a>ByteArrayOutputStream类</h4><p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-bytearrayoutputstream.html">Java ByteArrayOutputStream类</a></p>
<h4 id="InetAddress类和InetSocketAddress的使用"><a href="#InetAddress类和InetSocketAddress的使用" class="headerlink" title="InetAddress类和InetSocketAddress的使用"></a>InetAddress类和InetSocketAddress的使用</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30702413/article/details/95484513">InetAddress类和InetSocketAddress</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">SocketAddress address = <span class="keyword">new</span> InetSocketAddress( <span class="string">&quot;www.fortify.net&quot;</span> , <span class="number">443</span> );</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     socket.connect(address);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125; <span class="comment">// 连接远程主机</span></span><br><span class="line">Thread reader = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span> [ <span class="number">512</span> ];</span><br><span class="line">             InputStream stream = socket.getInputStream();</span><br><span class="line">             socket.getInputStream().read(buffer);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"> </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">reader.start();</span><br></pre></td></tr></table></figure>

<h4 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/y4247464/p/12182801.html">TCP——并发服务</a><br>虽然是C语言的，但是关于并发服务器的讨论思想可以学习。<br><img src="/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A12/2.png"><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waller/p/11352073.html">TCP服务端实现并发</a></p>
<h4 id="自定义添加header"><a href="#自定义添加header" class="headerlink" title="自定义添加header"></a>自定义添加header</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42120550/article/details/118820176">在Java中的HTTP请求中添加HEADER</a><br>HTTP请求是使用PrintWriter类添加header，看看socket通信时能不能使用这种方法添加一个header。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Socket s = <span class="keyword">new</span> Socket ();</span><br><span class="line">s.bind (<span class="keyword">new</span> InetSocketAddress (ipFrom, <span class="number">0</span>));</span><br><span class="line">s.connect (<span class="keyword">new</span> InetSocketAddress (ipTo, <span class="number">80</span>), <span class="number">1000</span>);</span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter (s.getOutputStream ());</span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader (<span class="keyword">new</span> InputStreamReader (s.getInputStream ()));</span><br><span class="line">writer.print (<span class="string">&quot;GET &quot;</span> + szUrl + <span class="string">&quot; HTTP/1.0\r\n\r\n&quot;</span>);</span><br><span class="line">writer.flush ();</span><br><span class="line">s .close ();</span><br><span class="line">reader.close ();</span><br><span class="line">writer.close ();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">Socket局域网通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-30 14:12:15 / 修改时间：17:58:19" itemprop="dateCreated datePublished" datetime="2021-12-30T14:12:15+08:00">2021-12-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pashanhu6402/article/details/96428887">Socket原理讲解</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/android-tutorial-socket1.html">基于TCP协议的Socket通信(1)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Sara_YF/article/details/51628220">局域网内主机之间Socket通信实现</a></p>
<h3 id="Socket含义"><a href="#Socket含义" class="headerlink" title="Socket含义"></a>Socket含义</h3><p>Socket套接字。网络中的进程是通过socket来通信，socket起源于Unix，Unix/Linux都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。</p>
<h3 id="Socket的基本操作"><a href="#Socket的基本操作" class="headerlink" title="Socket的基本操作"></a>Socket的基本操作</h3><h4 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。<br>创建socket的时候，可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p>
<ul>
<li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。<br>协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li>
<li>protocol：指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</li>
</ul>
<p><strong>注意：</strong>并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。<br>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h4 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h4><p>bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<p>函数的三个参数分别为：</p>
<ul>
<li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：<br>struct sockaddr_in {<br>  sa_family_t    sin_family;<br>  in_port_t      sin_port;<br>  struct in_addr sin_addr;<br>};<br>struct in_addr {<br>  uint32_t       s_addr;<br>};</li>
</ul>
<p>ipv6对应的是：<br>struct sockaddr_in6 {<br>    sa_family_t     sin6_family;<br>    in_port_t       sin6_port;<br>    uint32_t        sin6_flowinfo;<br>    struct in6_addr sin6_addr;<br>    uint32_t        sin6_scope_id;<br>};<br>struct in6_addr {<br>    unsigned char   s6_addr[16];<br>};</p>
<p>Unix域对应的是：<br>#define UNIX_PATH_MAX    108</p>
<p>struct sockaddr_un {<br>    sa_family_t sun_family;<br>    char        sun_path[UNIX_PATH_MAX];<br>};</p>
<ul>
<li>addrlen：对应的是地址的长度。</li>
</ul>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<blockquote>
<p><strong>网络字节序与主机字节序</strong><br>主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。<br>引用标准的Big-Endian和Little-Endian的定义如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>&nbsp;&nbsp;&nbsp;&nbsp;b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p>
</blockquote>
<blockquote>
<p>网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p>
</blockquote>
<blockquote>
<p>所以： 在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于 这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再 赋给socket。</p>
</blockquote>
<h4 id="listen-、connect-函数"><a href="#listen-、connect-函数" class="headerlink" title="listen()、connect()函数"></a>listen()、connect()函数</h4><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。<br>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h4 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h4><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>
<p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。<br>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h4 id="read-、write-等函数"><a href="#read-、write-等函数" class="headerlink" title="read()、write()等函数"></a>read()、write()等函数</h4><p>服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网络中不同进程之间的通信！网络I/O操作有下面几组：<br>read()/write()<br>recv()/send()<br>readv()/writev()<br>recvmsg()/sendmsg()<br>recvfrom()/sendto()</p>
<h4 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h4><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。<br>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
<h4 id="socket函数与通信过程"><a href="#socket函数与通信过程" class="headerlink" title="socket函数与通信过程"></a>socket函数与通信过程</h4><p><img src="/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/1.png"></p>
<h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><h4 id="短连接："><a href="#短连接：" class="headerlink" title="短连接："></a>短连接：</h4><pre><code>连接-&gt;传输数据-&gt;关闭连接
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。
</code></pre>
<h4 id="长连接："><a href="#长连接：" class="headerlink" title="长连接："></a>长连接：</h4><pre><code>连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。 -&gt;关闭连接。
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
</code></pre>
<h4 id="http的长连接："><a href="#http的长连接：" class="headerlink" title="http的长连接："></a>http的长连接：</h4><pre><code>HTTP也可以建立长连接，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。
HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持，但还是无状态的,或者说是不可以信任的。
</code></pre>
<h3 id="TCP粘包、拆包"><a href="#TCP粘包、拆包" class="headerlink" title="TCP粘包、拆包"></a>TCP粘包、拆包</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/panchanggui/p/9518735.html">TCP粘包，拆包及解决方法</a><br>粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p>
<h4 id="什么是粘包和拆包"><a href="#什么是粘包和拆包" class="headerlink" title="什么是粘包和拆包"></a>什么是粘包和拆包</h4><p>假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：<br>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。<br><img src="/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/3.png"><br>第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。<br><img src="/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/4.png"><br>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。<br><img src="/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/5.png"><br><img src="/2021/12/30/Socket%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1/6.png"></p>
<h4 id="TCP粘包和拆包的原因"><a href="#TCP粘包和拆包的原因" class="headerlink" title="TCP粘包和拆包的原因"></a>TCP粘包和拆包的原因</h4><p>1.应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。<br>2.应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。<br>3.进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。<br>4.接收方法不及时读取套接字缓冲区数据，这将发生粘包。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。<br>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。<br>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/" class="post-title-link" itemprop="url">设计模式2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-30 10:36:40 / 修改时间：10:38:23" itemprop="dateCreated datePublished" datetime="2021-12-30T10:36:40+08:00">2021-12-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/29/HTTP%E9%80%9A%E4%BF%A12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/HTTP%E9%80%9A%E4%BF%A12/" class="post-title-link" itemprop="url">HTTP通信2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 10:14:08" itemprop="dateCreated datePublished" datetime="2021-12-29T10:14:08+08:00">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-30 14:04:57" itemprop="dateModified" datetime="2021-12-30T14:04:57+08:00">2021-12-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HttpUrlConnect是JAVA的原生类，HttpClient是Apache Jakarta Common下的子项目，支持HTTP协议的客户端编程工具包。这是<a target="_blank" rel="noopener" href="https://www.cnblogs.com/UUUz/p/9990891.html">Httpclient和HttpUrlConnect区别</a>。<br>关于URLConnection还可以看：<a target="_blank" rel="noopener" href="http://www.blogjava.net/supercrsky/articles/247449.html">JDK中的URLConnection参数详解</a>。<br>有时间可以了解<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shenjiangwei/p/11068312.html">HttpClient的使用方法</a>。</p>
<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/117264481886">Java代码发送Http的GET和POST请求</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0842b888d94a">如何在Java中发送HTTP GET/POST请求</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiqishuang/article/details/51644372">Java发送http的get、post、put请求</a><br>在看代码的过程中涉及到的知识点：</p>
<ul>
<li>UserAgent:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c5cf6a1967d1">查看方式</a></li>
<li>OutputStreamWriter类：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ai_bao_zi/article/details/81168420">JAVA基础知识之OutputStreamWriter流</a></li>
<li>DataOutputStream类：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lili13897741554/article/details/81876443">Java IO流</a><blockquote>
<p>writeByte(int v)—将一个字节写到数据输出流中(实际是基础输出流)</p>
</blockquote>
</li>
<li>InputStream类：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ddd295569371/article/details/104430626">getInputStream与getOutputStream详解</a><blockquote>
<p>getOutputStream方法得到的是一个输出流，客户端的Socket对象上的getOutputStream方法得到的输出流其实就是发送给服务器端的数据。</p>
</blockquote>
</li>
</ul>
<p>使用gin编写的r.POST(“/somePost”, postting),postting内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postting</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	message := c.PostForm(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">	nick := c.DefaultPostForm(<span class="string">&quot;nick&quot;</span>, <span class="string">&quot;anonymous&quot;</span>)</span><br><span class="line"></span><br><span class="line">	c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;status&quot;</span>:  <span class="string">&quot;posted&quot;</span>,</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: message,</span><br><span class="line">		<span class="string">&quot;nick&quot;</span>:    nick,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Postman可以看到/somePost能够被访问。<br><img src="/2021/12/29/HTTP%E9%80%9A%E4%BF%A12/1.png"><br>Java运行访问到/somePost,读取并修改其中的JSon数据：<br><img src="/2021/12/29/HTTP%E9%80%9A%E4%BF%A12/6.png"></p>
<h4 id="POST表单"><a href="#POST表单" class="headerlink" title="POST表单"></a>POST表单</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Icywind1/article/details/85628099">multipart/form-data的方式传递参数</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mufengforward/p/10510337.html">java中的http请求的封装（GET、POST、form表单形式）</a></p>
<h3 id="PUT请求"><a href="#PUT请求" class="headerlink" title="PUT请求"></a>PUT请求</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zcf520android/article/details/51314959">HttpURLConnection 发送PUT请求</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36666651/article/details/79835777">使用HttpURLConnection的put或者post请求上传文件</a><br><a target="_blank" rel="noopener" href="https://codingdict.com/questions/134100">HttpURLConnection发送PUT，DELETE HTTP请求</a></p>
<p>使用gin编写的r.PUT(“/somePut”, putting),putting内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putting</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;status&quot;</span>:  <span class="string">&quot;put&quot;</span>,</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">		<span class="string">&quot;nick&quot;</span>:    <span class="string">&quot;456&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Postman可以看到/somePut能够被访问。<br><img src="/2021/12/29/HTTP%E9%80%9A%E4%BF%A12/2.png"><br>Java运行访问到/somePut,读取其中的JSon数据：<br><img src="/2021/12/29/HTTP%E9%80%9A%E4%BF%A12/5.png"></p>
<h3 id="DELETE请求"><a href="#DELETE请求" class="headerlink" title="DELETE请求"></a>DELETE请求</h3><p>使用gin编写的r.DELETE(“/someDELETE”, delete),delete内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	nick := c.DefaultPostForm(<span class="string">&quot;nick&quot;</span>, <span class="string">&quot;sandy&quot;</span>)</span><br><span class="line">	c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;status&quot;</span>:  <span class="string">&quot;delete&quot;</span>,</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: <span class="string">&quot;helloworld&quot;</span>,</span><br><span class="line">		<span class="string">&quot;nick&quot;</span>:    nick,</span><br><span class="line">        <span class="string">&quot;describtion&quot;</span>: <span class="string">&quot;this is a delete request&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Postman可以看到/someDELETE能够被访问。<br><img src="/2021/12/29/HTTP%E9%80%9A%E4%BF%A12/3.png"><br>Java运行访问到/someDELETE,读取其中的JSon数据：<br><img src="/2021/12/29/HTTP%E9%80%9A%E4%BF%A12/4.png"></p>
<h3 id="PUT请求上传文件"><a href="#PUT请求上传文件" class="headerlink" title="PUT请求上传文件"></a>PUT请求上传文件</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangchengzi/p/9865100.html">给idea设置默认使用的maven配置</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38384994/article/details/115116418">idea配置自带maven</a></p>
<p>HTTP请求类型的一般用法：<br>POST上传，GET获取，PUT修改，DELETE删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/28/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/28/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">go语言使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-28 17:08:51" itemprop="dateCreated datePublished" datetime="2021-12-28T17:08:51+08:00">2021-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-29 17:47:47" itemprop="dateModified" datetime="2021-12-29T17:47:47+08:00">2021-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://192.168.2.35/help/2021/05/27/dev/go/go-quickstart/">团队知识库-go快速入门</a></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6046.html">Go语言程序的编译和运行</a></p>
<h3 id="go环境搭建"><a href="#go环境搭建" class="headerlink" title="go环境搭建"></a>go环境搭建</h3><p>创建项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建test目录</span><br><span class="line">mkdir test</span><br><span class="line"># 切换到test</span><br><span class="line">cd test</span><br><span class="line"># 初始化项目</span><br><span class="line">go mod init test</span><br></pre></td></tr></table></figure>

<p>查看环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>

<p>设置代理,提高访问github的速度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.io,direct</span><br></pre></td></tr></table></figure>

<h3 id="VSCode安装Go环境"><a href="#VSCode安装Go环境" class="headerlink" title="VSCode安装Go环境"></a>VSCode安装Go环境</h3><p>扩展搜索Go并安装，同时安装提示所需要的安装包。</p>
<h3 id="Go-gin的使用"><a href="#Go-gin的使用" class="headerlink" title="Go gin的使用"></a>Go gin的使用</h3><p><a target="_blank" rel="noopener" href="https://github.com/gin-gonic/gin">gin使用方法-github</a></p>
<p>下载gin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<p>import包，添加代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main   </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span>      </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World!&quot;</span>) </span><br><span class="line">    r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终端运行。注意终端打开的文件夹需要是包含该go程序的mod文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run ./test.go</span><br></pre></td></tr></table></figure>

<p>最后访问<a target="_blank" rel="noopener" href="http://localhost:8080/ping%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E7%95%8C%E9%9D%A2%EF%BC%9A">http://localhost:8080/ping，可以看到如下界面：</a></p>
<p><img src="/2021/12/28/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/1.png"></p>
<h3 id="Go运行方法"><a href="#Go运行方法" class="headerlink" title="Go运行方法"></a>Go运行方法</h3><ol>
<li><p>go build</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build ./test.go</span><br><span class="line">./test.exe</span><br></pre></td></tr></table></figure>

<p>会生成同名的.exe文件，不需要依赖环境就可运行。</p>
</li>
<li><p>go run</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run ./test.go</span><br></pre></td></tr></table></figure>

<p>直接运行。</p>
</li>
</ol>
<h3 id="Gin学习"><a href="#Gin学习" class="headerlink" title="Gin学习"></a>Gin学习</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013210620/article/details/82773905">golangWeb框架—github.com/gin-gonic/gin学习</a></p>
<h4 id="post传参"><a href="#post传参" class="headerlink" title="post传参"></a>post传参</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	router.POST(<span class="string">&quot;/someGet&quot;</span>, getting)</span><br><span class="line">	router.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getting</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">	message := c.PostForm(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">	nick := c.DefaultPostForm(<span class="string">&quot;nick&quot;</span>, <span class="string">&quot;anonymous&quot;</span>)</span><br><span class="line"></span><br><span class="line">	c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;status&quot;</span>:  <span class="string">&quot;posted&quot;</span>,</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: message,</span><br><span class="line">		<span class="string">&quot;nick&quot;</span>:    nick,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是post方式，不能通过浏览器输入网址（get）访问，使用postman，效果图如下：<br><img src="/2021/12/28/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/2.png"></p>
<p>可以通过传值修改json字段<br><img src="/2021/12/28/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/3.png"></p>
<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><ol>
<li>首先建立新的空文件夹</li>
<li>初始化：go mod init upfile</li>
<li>将github的<a target="_blank" rel="noopener" href="https://github.com/gin-gonic/examples/tree/master/upload-file/single">示例代码</a>导入到本地</li>
<li>下载import包：go get github.com/gin-gonic/gin</li>
<li>运行：go run ./main.go</li>
<li>直接访问localhost:8080，看到如下页面：<br><img src="/2021/12/28/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/4.png"><br>ps：<a target="_blank" rel="noopener" href="https://www.pianshen.com/article/15081184761/">Psotman-POST方式上传文件</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/" class="post-title-link" itemprop="url">多线程下载文件3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-28 09:24:46" itemprop="dateCreated datePublished" datetime="2021-12-28T09:24:46+08:00">2021-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-29 17:46:42" itemprop="dateModified" datetime="2021-12-29T17:46:42+08:00">2021-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="文件下载速度统计"><a href="#文件下载速度统计" class="headerlink" title="文件下载速度统计"></a>文件下载速度统计</h3><p><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/350233729">java 文件下载 怎么提升速度？</a><br>提高文件下载速度一方面是缓冲，另一方面就是多线程。<br>由于多线程已经存在了，将原来的缓冲1024改为8192。<br>运行速度有提高，下载时间为2.3分钟。<br><img src="/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/1.png"><br>缓冲区大小1024<em>1024</em>5，但是运行时间为2.48<br><img src="/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/2.png"><br>缓冲区大小10*1024，下载时间为2.61分钟<br><img src="/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/3.png"></p>
<p>单线程下载约1分钟。<br><img src="/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/4.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/aokunsang-1069794">多线程分段下载文件</a><br>用上述方法下载文件时，开启3个线程与开启10个线程下载时间相似，均为55s。</p>
<p><strong>IDEA代码格式调整：</strong>ctrl+alt+L</p>
<h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/IT-CPC/p/10898871.html">同步(Synchronous)和异步(Asynchronous)</a></p>
<h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><p>将线程读取的文件的启动位置的方式做了修改。之前采用的时InputStream类中的skip方法，现在更改为HttpURLConnection的setRequestProperty方法，将range参数直接修改。<br><img src="/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/6.png"><br>现在的下载速度为：<br><img src="/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/5.png"><br>比最早的单线程快了一点点。<br>此时程序的线程数量与下载速度如下表格：</p>
<table>
<tr>
<th>线程数量</th>
<th>下载时间1</th>
<th>下载时间2</th>
<th>下载时间3</th>
</tr>
<tr>
<td>3</td>
<td>70724ms</td>
<td>69213ms</td>
<td>71868ms</td>
</tr>
<tr>
<td>5</td>
<td>62925ms</td>
<td>67650ms</td>
<td>ms</td>
</tr>
<tr>
<td>10</td>
<td>62468ms</td>
<td>71192ms</td>
<td>ms</td>
</tr>
<tr>
<td>30</td>
<td>56942ms</td>
<td>ms</td>
<td>ms</td>
</tr>
<tr>
<td>50</td>
<td>54040ms</td>
<td>ms</td>
<td>ms</td>
</tr>
</table>
浏览器直接下载文件的时间是1分14秒。迅雷下载文件的时间是55秒。

<p>为什么下载时间降幅5到10没有那么快？<br>10个线程和100个线程比起来，不见得速度就可以快，搞不好因为线程间的任务切换，速度还会要慢一些的。</p>
<p>同时多试几次下载时间是否有区别？<br>网络状态不同时，下载时间也不同。</p>
<p>发现每个线程下载的时候长度是比原来设定的size要大的。<br><img src="/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/10.png"><br>是因为没有设置endPos。<br>conn.setRequestProperty(“Range”, “bytes=” + this.startPos + “-“+ this.endPos);<br>但是由于startPos设置了，并且是对同一个文件进行操作，所以多下载的一部分每次都被覆盖了。所以下载的文件没有问题。<br>设置了endPos后，基本和原先设定的size长度相同了。<br><img src="/2021/12/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B63/11.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/27/HTTP%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/27/HTTP%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">HTTP通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-27 13:57:30" itemprop="dateCreated datePublished" datetime="2021-12-27T13:57:30+08:00">2021-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-29 17:47:14" itemprop="dateModified" datetime="2021-12-29T17:47:14+08:00">2021-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/y_bing/article/details/83042418">java HTTP通信</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yico/p/5179091.html">Http四种请求方式:post ,get ,put,delete</a></p>
<h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String message=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url=<span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">            HttpURLConnection connection= (HttpURLConnection) url.openConnection();</span><br><span class="line">            connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">            connection.setConnectTimeout(<span class="number">5</span>*<span class="number">1000</span>);  <span class="comment">//设置超时时间为5秒</span></span><br><span class="line">            connection.connect();</span><br><span class="line">            InputStream inputStream=connection.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length=inputStream.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                String s=<span class="keyword">new</span> String(data, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">                sb.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            message=sb.toString();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/27/HTTP%E9%80%9A%E4%BF%A1/1.png"></p>
<h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012869196/article/details/84076705">HttpPost工具类使用教程</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014672511/article/details/80425808">HTTP_POST请求的数据格式</a><br>在HTTP的请求头中，可以使用Content-type来指定不同格式的请求信息。</p>
<h4 id="Content-type的类型"><a href="#Content-type的类型" class="headerlink" title="Content-type的类型"></a>Content-type的类型</h4><p><strong>常见的媒体格式类型</strong></p>
<ul>
<li>text/html ： HTML格式</li>
<li>text/plain ：纯文本格式</li>
<li>text/xml ：  XML格式</li>
<li>image/gif ：gif图片格式</li>
<li>image/jpeg ：jpg图片格式</li>
<li>image/png ：png图片格式</li>
</ul>
<p><strong>以applicaton开头的媒体类型</strong></p>
<ul>
<li>application/json    ： JSON数据格式</li>
<li>application/xhtml+xml ：XHTML格式</li>
<li>application/xml     ： XML数据格式</li>
<li>application/atom+xml  ：Atom XML聚合格式    </li>
<li>application/pdf       ：pdf格式  </li>
<li>application/javascript ：js格式</li>
<li>application/msword  ： Word文档格式</li>
<li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application/x-www-form-urlencoded ：form表单默认的数据格式类型，form表单数据被编码为key/value格式发送到服务器。</li>
</ul>
<p><strong>另外一种常见的媒体格式是上传文件之时使用的：</strong></p>
<ul>
<li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式。</li>
</ul>
<h4 id="常用类型案例"><a href="#常用类型案例" class="headerlink" title="常用类型案例"></a>常用类型案例</h4><ol>
<li><p>application/x-www-form-urlencoded，form表单默认的数据格式，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。比如下面的http请求格式：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Request Headers</span><br><span class="line"></span><br><span class="line"><span class="keyword">POST</span> <span class="string">/adduser</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8030</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>16</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcm</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line"><span class="fortran"></span></span><br><span class="line"><span class="fortran"># <span class="keyword">Form</span> <span class="keyword">Data</span></span></span><br><span class="line"><span class="fortran"></span></span><br><span class="line"><span class="fortran"><span class="keyword">name</span>=<span class="keyword">name</span>&amp;age=<span class="number">11</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>application/json，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。服务端语言也有很多函数去解析JSON，使用JSON可以支持更加复杂的结构化数据。比如下面的http请求格式：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Request Headers</span><br><span class="line"></span><br><span class="line"><span class="keyword">POST</span> <span class="string">/adduser</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8030</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>24</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcm</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line"><span class="vala"></span></span><br><span class="line"><span class="vala"><span class="meta"># Request Payload</span></span></span><br><span class="line"><span class="vala"></span></span><br><span class="line"><span class="vala">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;121&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">121</span>&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>multipart/form-data，对用于在表单中上传文件时，也可以上传普通数据，只需要让from的Content-Type等于multipart/form-data就可以了。比如下面的http请求格式：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Request Header</span><br><span class="line"></span><br><span class="line"><span class="keyword">POST</span> <span class="string">/adduser</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8030</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>232</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcm</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryBRi81vNtMyBL97Rb</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line"><span class="applescript"></span></span><br><span class="line"><span class="applescript"><span class="comment"># Request Payload</span></span></span><br><span class="line"><span class="applescript"></span></span><br><span class="line"><span class="applescript"><span class="comment">------WebKitFormBoundaryBRi81vNtMyBL97Rb</span></span></span><br><span class="line"><span class="applescript">Content-Disposition: form-data; <span class="built_in">name</span>=<span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="applescript"></span></span><br><span class="line"><span class="applescript">name1</span></span><br><span class="line"><span class="applescript"><span class="comment">------WebKitFormBoundaryBRi81vNtMyBL97Rb</span></span></span><br><span class="line"><span class="applescript">Content-Disposition: form-data; <span class="built_in">name</span>=<span class="string">&quot;age&quot;</span></span></span><br><span class="line"><span class="applescript"></span></span><br><span class="line"><span class="applescript"><span class="number">12</span></span></span><br><span class="line"><span class="applescript"><span class="comment">------WebKitFormBoundaryBRi81vNtMyBL97Rb--</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>DELETE方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">connection.setRequestMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B62/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B62/" class="post-title-link" itemprop="url">多线程下载文件2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-27 09:48:26" itemprop="dateCreated datePublished" datetime="2021-12-27T09:48:26+08:00">2021-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-29 17:46:22" itemprop="dateModified" datetime="2021-12-29T17:46:22+08:00">2021-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31615049/article/details/88562892">RandomAccessFile简介与使用</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24434671/article/details/90270161?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242.1">RandomAccessFile使用场景及总结</a></p>
<h2 id="RandomAccessFile类详解"><a href="#RandomAccessFile类详解" class="headerlink" title="RandomAccessFile类详解"></a>RandomAccessFile类详解</h2><p>RandomAccessFile是不属于InputStream和OutputStream类系的。实际上，除了实现DataInput和DataOutput接口之外(DataInputStream和DataOutputStream也实现了这两个接口)，它和这两个类系毫不相干，甚至都没有用InputStream和OutputStream已经准备好的功能；它是一个完全独立的类，所有方法(绝大多数都只属于它自己)都是从零开始写的。这可能是因为RandomAccessFile能在文件里面前后移动，所以它的行为与其它的I/O类有些根本性的不同。总而言之，它是一个直接继承Object的，独立的类。</p>
<h3 id="RandomAccessFile作用"><a href="#RandomAccessFile作用" class="headerlink" title="RandomAccessFile作用"></a>RandomAccessFile作用</h3><p>平常创建流对象关联文件,开始读文件或者写文件都是从头开始的,不能从中间开始,如果是开多线程下载一个文件我们之前学过的FileWriter或者FileReader等等都无法完成,而当前介绍的RandomAccessFile他就可以解决这个问题,因为它可以指定位置读,指定位置写的一个类,通常开发过程中,<strong>多用于多线程下载一个大文件</strong>等场景。</p>
<h3 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h3><table>
<tr>
    <td>r</td>
    <td>以只读的方式打开文本，也就意味着不能用write来操作文件</td>
</tr>
<tr>
    <td>rw</td>
    <td>读操作和写操作都是允许的</td>
</tr>
<tr>
    <td>rws</td>
    <td>每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</td>
</tr>
<tr>
    <td>rwd</td>
    <td>每当进行写操作，同步的刷新到磁盘，刷新内容</td>
</tr>
</table>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table>
<tr>
    <td>seek</td>
    <td>指定文件的光标位置，通俗点说就是指定你的光标位置，然后下次读文件数据的时候从该位置读取。</td>
</tr>
<tr>
    <td>getFilePointer</td>
    <td>我们注意到这是一个long类型的返回值，字面意思就是返回当前的文件光标位置。这样方便我们后面读取插入。</td>
</tr>
<tr>
    <td>length</td>
    <td>毫无疑问的方法，文件的长度，返回long类型。注意它并不会受光标的影响。只会反应客观的文本长度。</td>
</tr>
<tr>
    <td>read()、read(byte[] b)、read(byte[] b,int off,int len)</td>
    <td>这些方法跟readstream中的方法一样，例如最后一个：定义缓冲数组，从数组的off偏移量位置开始写，读取转换为数组数据达到len个字节。总之这是一个读文件内容的标准操作api。</td>
</tr>
<tr>
    <td>readDouble()、readFloat()、readBoolean()、readInt()、readLong()、readShort()、readByte()、readChar()</td>
    <td>去read每一个字符，返回他们的ASCII码</td>
</tr>
<tr>
    <td>readFully(byte[] b)</td>
    <td>这个方法的作用就是将文本中的内容填满这个缓冲区b。如果缓冲b不能被填满，那么读取流的过程将被阻塞，如果发现是流的结尾，那么会抛出异常。</td>
</tr>
<tr>
    <td>getChannel</td>
    <td>它返回的就是nio通信中的file的唯一channel</td>
</tr>
<tr>
    <td>skipBytes(int n)</td>
    <td>跳过n字节的位置，相对于当前的point。</td>
</tr>
</table>
得益于seek的设计，多线程可以轮流操作seek控制光标的位置，从未达到不同线程的并发读写操作。

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>多线程复制文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomFileTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		String filePath = <span class="string">&quot;C:\Users\wangsy\Pictures\Saved Pictures\10.png&quot;</span>;</span><br><span class="line">		<span class="comment">// 这里声明为偶数片数，下面会进行计算</span></span><br><span class="line">		<span class="keyword">int</span> parts = <span class="number">2</span>;</span><br><span class="line">		File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">		<span class="keyword">long</span> len = file.length();</span><br><span class="line">		<span class="comment">// 防止除法出校小数点，必须能整除才行</span></span><br><span class="line">		<span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			parts *= <span class="number">2</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			parts = parts * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts; i++) &#123;</span><br><span class="line">			<span class="comment">// 启动线程</span></span><br><span class="line">			<span class="keyword">new</span> ReadCopyMoreThreadFile(i, parts, file).start();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		System.out.println(<span class="string">&quot;多线程复制文件成功&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadCopyMoreThreadFile</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> parts = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> File file;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReadCopyMoreThreadFile</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> parts, File file)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.start = start;</span><br><span class="line">		<span class="keyword">this</span>.file = file;</span><br><span class="line">		<span class="keyword">this</span>.parts = parts;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第&quot;</span> + start + <span class="string">&quot;个线程正在运行！&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"> </span><br><span class="line">			<span class="comment">// 获取到文件的总长度</span></span><br><span class="line">			<span class="keyword">long</span> len = rf.length();</span><br><span class="line"> </span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 5174 * 0 / 2 = 0 5174 * 1 / 2 = 2587</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 跳到第start部分开始读</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			rf.seek(len * start / parts);</span><br><span class="line">			<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) (len / parts)];</span><br><span class="line">			<span class="comment">// 读取</span></span><br><span class="line">			rf.read(buf);</span><br><span class="line">			<span class="comment">// 关闭</span></span><br><span class="line">			rf.close();</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">int</span> index = file.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">			String newFileName = file.getName().substring(<span class="number">0</span>, index) + <span class="string">&quot;-bak_&quot;</span> + file.getName().substring(index);</span><br><span class="line">			<span class="comment">// 创建目标文件</span></span><br><span class="line">			rf = <span class="keyword">new</span> RandomAccessFile(newFileName, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">			<span class="comment">// 指针移动到需要写的位置</span></span><br><span class="line">			rf.seek(len * start / parts);</span><br><span class="line">			<span class="comment">// 写入</span></span><br><span class="line">			rf.write(buf);</span><br><span class="line">			<span class="comment">// 关闭</span></span><br><span class="line">			rf.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread的run与start"><a href="#Thread的run与start" class="headerlink" title="Thread的run与start"></a>Thread的run与start</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31854907/article/details/108452329">Thread的run()与start()的区别</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xmtblog/article/details/102774484?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.highlightwordscore&spm=1001.2101.3001.4242.2">Thread的start和run的区别</a></p>
<h3 id="start-、run-方法的定义区分"><a href="#start-、run-方法的定义区分" class="headerlink" title="start()、run()方法的定义区分"></a>start()、run()方法的定义区分</h3><p><strong>start():</strong><br>用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。<br>通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行， 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br><strong>Run():</strong><br>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待Run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。<br><strong>总结：</strong><br>调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p>
<h3 id="run-方法的调用"><a href="#run-方法的调用" class="headerlink" title="run()方法的调用"></a>run()方法的调用</h3><p>当一个线程被创建完成后（new），我们可以通过start()方法进行线程的启动，而线程的任务处理是在run()方法中进行的。</p>
<h3 id="start方法中的基本流程"><a href="#start方法中的基本流程" class="headerlink" title="start方法中的基本流程"></a>start方法中的基本流程</h3><p><img src="/2021/12/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B62/1.jpg"></p>
<h2 id="InputStream类解析"><a href="#InputStream类解析" class="headerlink" title="InputStream类解析"></a>InputStream类解析</h2><p><a target="_blank" rel="noopener" href="http://www.51gjie.com/java/1154.html">Java InputStream.skip()介绍</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/nuccch/article/details/23399107">关于UrlHttpConnection.setRequestProperty()的调用顺序问题的验证</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain; charset=utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//conn.connect();</span></span><br><span class="line">InputStream is = conn.getInputStream();</span><br></pre></td></tr></table></figure>
<p>不论是否明确调用connect()方法，通过setRequestProperty(name,value)设置的属性都生效了，那这是为什么呢？<br>在调用getInputStream()方法中会检查连接是否已经建立，如果没有建立，则会调用connect()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C://51gjie.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((i = is.read()) != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>) i;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符: &quot;</span> + c);</span><br><span class="line">        is.skip(<span class="number">1</span>); <span class="comment">//跳过1个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputStream.skip()此方法是从输入流的当前位置往后跳过n个字符，这样这n个字符就丢失了。当然如果你要找回，可以直接mark，并且reset当前的流位置，重新获取流就可以了。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/HuntCode/article/details/47016529?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-3.highlightwordscore&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-3.highlightwordscore">HTTP下载文件时getContentLength()返回-1</a><br>下载大文件，发现在下载文件较小的时候能够获取到正确的contentlength值，一旦下载文件超过2G大小contentlength的值就是-1，在网上找相关解答，都是说要取消gzip文件压缩方式,添加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.setRequestProperty(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;identity&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>试过后还是不能得到大文件的contentlength值，后来无意间看到getContentLength方法的描述，发现该方法返回的是int类型的值，这才恍然大悟，超过2G的值是不能用int表示的，所以只会返回-1。解决方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getContentSize</span><span class="params">(HttpURLConnection conn)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> contentSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; ; i++)&#123;</span><br><span class="line">		String mine = conn.getHeaderFieldKey(i);</span><br><span class="line">		<span class="keyword">if</span>(mine == <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(mine.equals(<span class="string">&quot;Content-Length&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			contentSize = Long.parseLong(conn.getHeaderField(i));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> contentSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载文件途中发现到达2G后监视下载进度从53%变成了-52%，发现监视使用的长度类型为int，将其修改为long。能正常下载成功。<br>统计下载时间，发现java多线程下载时间为2.7分钟。<br><img src="/2021/12/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B62/2.png"><br>浏览器下载时间为1.2分钟。</p>
<p>猜测是统计的时长出了问题。<br>测试发现统计时长的方法没问题，可能是多线程没有并发运行？等明天再看一下。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sandy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sandy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
