<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="进程与线程学习当VS中提示没有添加引用空间时，尝试alt+shift+F10 Process类的用法进程的基本用法进程：我们可以把计算机中每一个运行的应用程序都当做是一个进程。 而一个进程是由多个线程组成的。 1234567891011121314151617Process [] pros &#x3D; Process.GetProcesses();&#x2F;&#x2F;获取所有进程的列表foreach (var in pr">
<meta property="og:type" content="article">
<meta property="og:title" content="进程与线程学习">
<meta property="og:url" content="http://example.com/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Sandy的学习之路">
<meta property="og:description" content="进程与线程学习当VS中提示没有添加引用空间时，尝试alt+shift+F10 Process类的用法进程的基本用法进程：我们可以把计算机中每一个运行的应用程序都当做是一个进程。 而一个进程是由多个线程组成的。 1234567891011121314151617Process [] pros &#x3D; Process.GetProcesses();&#x2F;&#x2F;获取所有进程的列表foreach (var in pr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.png">
<meta property="og:image" content="http://example.com/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/3.png">
<meta property="og:image" content="http://example.com/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/4.png">
<meta property="og:image" content="http://example.com/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/5.png">
<meta property="article:published_time" content="2021-12-10T01:05:23.000Z">
<meta property="article:modified_time" content="2021-12-14T06:23:30.054Z">
<meta property="article:author" content="Sandy">
<meta property="article:tag" content="进程线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.png">

<link rel="canonical" href="http://example.com/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>进程与线程学习 | Sandy的学习之路</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sandy的学习之路</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">27</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sandy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sandy的学习之路">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程与线程学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-10 09:05:23" itemprop="dateCreated datePublished" datetime="2021-12-10T09:05:23+08:00">2021-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-14 14:23:30" itemprop="dateModified" datetime="2021-12-14T14:23:30+08:00">2021-12-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C#</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="进程与线程学习"><a href="#进程与线程学习" class="headerlink" title="进程与线程学习"></a>进程与线程学习</h3><p>当VS中提示没有添加引用空间时，尝试alt+shift+F10</p>
<h4 id="Process类的用法"><a href="#Process类的用法" class="headerlink" title="Process类的用法"></a>Process类的用法</h4><h5 id="进程的基本用法"><a href="#进程的基本用法" class="headerlink" title="进程的基本用法"></a>进程的基本用法</h5><p>进程：我们可以把计算机中每一个运行的应用程序都当做是一个进程。</p>
<p>而一个进程是由多个线程组成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Process [] pros = Process.GetProcesses();//获取所有进程的列表</span><br><span class="line">foreach (var in pros)</span><br><span class="line">&#123;</span><br><span class="line">    //item.kill();  将所有进程杀死</span><br><span class="line">&#125;</span><br><span class="line">//通过进程打开一些应用程序</span><br><span class="line">Process.Start(&quot;calc&quot;);</span><br><span class="line">Process.Start(&quot;mspaint&quot;);</span><br><span class="line">Process.Start(&quot;notepad&quot;);</span><br><span class="line">Process.Start(&quot;iexplore&quot;,&quot;http://www.baidu.com&quot;);</span><br><span class="line"></span><br><span class="line">//通过进程打开指定的文件</span><br><span class="line">ProcessStartInfo psi = new ProcessStartInfo(@&quot;C:\Users\Admistrator\Desktop\1.txt&quot;);</span><br><span class="line">Process p = new Process();</span><br><span class="line">p.StartInfo = psi;</span><br><span class="line">p.Start();</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>

<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>单线程给我们带来的问题：窗体假死，主线程在执行功能时窗体无法被关闭，也不能拖拽移动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread th;</span><br><span class="line">private void button1_Click(object sender,EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个线程去执行方法Test</span><br><span class="line">    th = new Thread(Test);</span><br><span class="line">    //将线程设置为后台线程</span><br><span class="line">    th.IsBackground = true;</span><br><span class="line">    //标记这个线程准备就绪了，可以随时被执行。具体什么时候执行这个线程，由cpu决定</span><br><span class="line">    th.Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程分为两种，前台线程和后台线程。</p>
<p>前台线程：只有所有的前台线程都关闭才能完成程序关闭。</p>
<p>后台线程：只要所有的前台线程结束，后台线程自动结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void Test()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; 1 &lt; 1000; i++)</span><br><span class="line">        //Console.WriteLine(i);</span><br><span class="line">        textBox1.Text = i.ToString();</span><br><span class="line">    //textBox1是主线程创建的控件，新的线程现在调用Test()方法，这是不行的。在.NET下是不允许跨线程访问的。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要上述情况可行，需要新增下边的方法来取消跨线程的访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void Form1_Load(object sender,EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    //取消跨线程的访问</span><br><span class="line">    Control.CheckForIllegalCrossThreadCalls = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭程序时释放了资源，新的线程可能没有马上结束，继续再访问某资源，访问不到则会抛出异常。</p>
<p>此时需要判断线程是否为now。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void Form1_FormClosing(object sender,FormClosingEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    //当你点击关闭窗体时，判断新线程是否为null</span><br><span class="line">    if(th!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        //终止这个线程，不能再被启用了，th.Start()没有用了</span><br><span class="line">        th.Abort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thead.sleep(3000);//以毫秒为单位，睡眠3秒</span><br></pre></td></tr></table></figure>

<p>如果线程执行的方法需要参数，那么要求这个参数必须是object类型。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender,EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    Thread th = new Thread(Test);</span><br><span class="line">    th.IsBackground = true;</span><br><span class="line">    th.Start(&quot;123&quot;);//传入线程执行方法所需要的参数</span><br><span class="line">&#125;</span><br><span class="line">private void Test(object s)</span><br><span class="line">&#123;</span><br><span class="line">    string ss = (string)s;</span><br><span class="line">   	for(int i = 0; 1 &lt; 1000; i++)</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><h5 id="线程的一些属性"><a href="#线程的一些属性" class="headerlink" title="线程的一些属性"></a>线程的一些属性</h5><p>线程一旦开始执行，IsAlive就是true，线程结束就变成了false。<br>线程结束的条件就是：线程构造函数传入的委托结束了执行。<br>线程一旦结束，就无法再重启。<br>每个线程都有个Name属性，通常用于调试。<br> 线程Name只能设置一次，以后更改会抛出异常。<br>静态的Thread.CurrentThead属性，会返回当前执行的线程 </p>
<h5 id="Join-and-Sleep"><a href="#Join-and-Sleep" class="headerlink" title="Join and Sleep"></a>Join and Sleep</h5><p>调用Join方法，就可以等待另一个线程结束。</p>
<p>添加超时<br>调用Join的时候，可以设置一个超时，用毫秒或者TimeSpan都可以。<br>如果返回true，那就是线程结束了；如果超时了，就返回false。<br>Thread.Sleep()方法会暂停当前的线程，并等一段时间。<br>注意：Thread.Sleep(0)这样调用会导致线程立即放弃本身当前的时间片，自动将CPU移交给其他线程。<br>Thread.Yield()做同样的事情，但是它只会把执行交给同一处理器上的其它线程。<br>当等待Sleep或者Join的时候，线程处于阻塞的状态。</p>
<h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>如果线程的执行由于某种原因导致暂定，那么就认为该线程被阻塞了。<br>例如在sleep或者通过join等待其他线程结束。<br>被阻塞的线程会立即将其处理器的时间片生成给其它线程，从此就不再消耗处理器时间，直到满足其阻塞条件为止。</p>
<h5 id="ThreadState"><a href="#ThreadState" class="headerlink" title="ThreadState"></a>ThreadState</h5><p>可以通过ThreadState这个属性来判断线程是否处于被阻塞的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool blocked = (someThread.ThreadState &amp; ThreadState.WaitSleepJoin) != 0;</span><br></pre></td></tr></table></figure>
<p>ThreadState是一个flag enum，通过按位的形式，可以合并数据的选项。<br>一般以0、1、10、100、1000的状态，按位与得到判断结果。 </p>
<h5 id="Unblocking"><a href="#Unblocking" class="headerlink" title="Unblocking"></a>Unblocking</h5><p>·当遇到下列四种情况的时候，就会解除阻塞:<br>·阻塞条件被满足<br>·操作超时（如果设置超时的话)<br>·通过Thread.Interrupt()进行打断<br>·通过Thread.Abort()进行中止</p>
<p><img src="/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.png"></p>
<h5 id="I-O-bound-和Computer-bound-或-CPU-Bound"><a href="#I-O-bound-和Computer-bound-或-CPU-Bound" class="headerlink" title="I/O-bound 和Computer-bound(或 CPU-Bound)"></a>I/O-bound 和Computer-bound(或 CPU-Bound)</h5><p>·一个花费大部分时间等待某事发生的操作称为I/O-bound<br>·I/O绑定操作通常涉及输入或输出，但这不是硬性要求:Thread.Sleep()也被视为IO-bound<br>·相反，一个花费大部分时间执行CPU密集型工作的操作称为Compute-bound。</p>
<h5 id="阻塞-和-忙等待（自旋）"><a href="#阻塞-和-忙等待（自旋）" class="headerlink" title="阻塞 和 忙等待（自旋）"></a>阻塞 和 忙等待（自旋）</h5><h6 id="IO-bound操作的工作方式有两种"><a href="#IO-bound操作的工作方式有两种" class="headerlink" title="IO-bound操作的工作方式有两种:"></a>IO-bound操作的工作方式有两种:</h6><pre><code>·在当前线程上同步的等待
    Console.ReadLine(),Thread.Sleep(),Thread.Join()...
·异步的操作，在稍后操作完成时触发一个回调动作。
</code></pre>
<p>·同步等待的IO-bound操作将大部分时间花在阻塞线程上。<br>·它们也可以周期性的在一个循环里进行“打转（自旋）”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(DeteTime.Now &lt; nextStartTime)</span><br><span class="line">    Thread.Sleep(100);</span><br><span class="line">while(DeteTime.Now &lt; nextStartTime);</span><br></pre></td></tr></table></figure>
<h6 id="在忙等待和阻塞方面有一些细微差别。"><a href="#在忙等待和阻塞方面有一些细微差别。" class="headerlink" title="在忙等待和阻塞方面有一些细微差别。"></a>在忙等待和阻塞方面有一些细微差别。</h6><p>·首先，如果您希望条件很快得到满足（可能在几微秒之内），则短暂自旋可能会很有效，因为它避免了上下文切换的开销和延迟。<br>    .NET Framework提供了特殊的方法和类来提供帮助SpinLock和 SpinWait.<br>·其次．阻塞也不是零成本。这是因为每个线程在生存期间会占用大约1MB的内存，并会给CLR和操作系统带来持续的管理开销。<br>·因此，在需要处理成百上千个并发操作的大量I/O-bound程序的上下文中，阻塞可能会很麻烦·所以，此类程序需要使用基于回调的方法，在等待时完全撤消其线程。</p>
<h5 id="本地local状态和共享share状态"><a href="#本地local状态和共享share状态" class="headerlink" title="本地local状态和共享share状态"></a>本地local状态和共享share状态</h5><h6 id="Local本地独立"><a href="#Local本地独立" class="headerlink" title="Local本地独立"></a>Local本地独立</h6><p>CLR为每个线程分配自己的内存栈（Stack）,以便使本地变量保持独立。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        new Thread(Go).Start(); //在新线程上调用Go()</span><br><span class="line">        Go(); //在main线程上调用Go()</span><br><span class="line">    &#125;</span><br><span class="line">    static void Go()</span><br><span class="line">    &#123;</span><br><span class="line">        //cycles是本地变量</span><br><span class="line">        //在每个线程的内存栈上，都会创建cycles独立的副本</span><br><span class="line">        for (int cycles = 0;cycles &lt; 5; cycles++)</span><br><span class="line">        &#123;</span><br><span class="line">            Cosole.WriteLine(&#x27;?&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //结果输出10个?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Shared共享"><a href="#Shared共享" class="headerlink" title="Shared共享"></a>Shared共享</h6><p>如果多个线程都引用到同一个对象的实例，那么它们就共享了数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ThreadTest</span><br><span class="line">&#123;</span><br><span class="line">    bool _done;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadTest tt= new ThreadTest();</span><br><span class="line">        new Thread(tt.Go).Start();</span><br><span class="line">        tt.Go();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    void Go() //这是一个实例方法</span><br><span class="line">    &#123;</span><br><span class="line">       if (!_done)</span><br><span class="line">       &#123;</span><br><span class="line">           _done = true;</span><br><span class="line">           Cosole.WriteLine(&quot;Done&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //由于两个线程是在同一个ThreadTest实例上调用的Go()，所以它们共享 _done</span><br><span class="line">    //结果就是只打印一次 Done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被Lambda表达式或者匿名委托所捕获的本地变量，会被编译器转换为的字段(field)，所以也会被共享。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    bool done = false;</span><br><span class="line">    ThreadStart action = () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        if(!done)</span><br><span class="line">        &#123;</span><br><span class="line">            done = true;</span><br><span class="line">            Console.WriteLine(&quot;Done&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    new Thread(action).Start();</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态字段(field)也会在线程间共享数据。</p>
<h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>上述例子就引出了线程安全这个关键概念（或者说缺乏线程安全)<br>·上述例子的输出实际上是无法确定的:<br>·有可能（理论上)“Done”会被打印两次。<br>·如果交换Go方法里语句的顺序，那么“Done”被打印两次的几率会大大增加<br>·因为一个线程可能正在评估if，而另外一个线程在执行WriteLine 语句，它还没来得及把done 设为true。</p>
<h5 id="锁定与线程安全"><a href="#锁定与线程安全" class="headerlink" title="锁定与线程安全"></a>锁定与线程安全</h5><p>在读取和写入共享数据的时候，通过使用一个互斥锁（exclusive lock)，就可以修复前面例子的问题。<br>C#使用lock语句来加锁<br>当两个线程同时竞争一个锁的时候（锁可以基于任何引用类型对象），一个线程会等待或阻塞，直到锁变成可用状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ThreadSafe</span><br><span class="line">&#123;</span><br><span class="line">    static bool _done;</span><br><span class="line">    static readonly object _locker = new object();</span><br><span class="line"></span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        new Thread(Go).Start();</span><br><span class="line">        Go();</span><br><span class="line">    &#125;</span><br><span class="line">    static void Go()</span><br><span class="line">    &#123;</span><br><span class="line">        lock(_locker)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!_done)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Done&quot;);</span><br><span class="line">                _done = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多线程上下文中，以这种方式避免不确定性的代码就叫做线程安全。<br>Lock不是线程安全的银弹，很容易忘记对字段加锁，lock也会引起一些问题（死锁)。</p>
<h5 id="向线程传递参数"><a href="#向线程传递参数" class="headerlink" title="向线程传递参数"></a>向线程传递参数</h5><p>如果你想往线程的启动方法里传递参数，最简单的方式是使用lambda表达式，在里面使用参数调用方法。(例子lambda)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    Thread t =new Thread(()=&gt; Print(&quot;Hello from t!&quot;));</span><br><span class="line">    t.Start();</span><br><span class="line">&#125;</span><br><span class="line">static void Print(string message)</span><br><span class="line">&#123;</span><br><span class="line">    Cosole.WriteLine(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以把整个逻辑都放在lambda 里面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    new Thread(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Cosole.WriteLine(&quot;I&#x27;m running on another thread!&quot;);</span><br><span class="line">        Cosole.WriteLine(&quot;This is so easy!&quot;);</span><br><span class="line">    &#125;).Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/3.png"></p>
<h5 id="Lambda表达式与被捕获的变量"><a href="#Lambda表达式与被捕获的变量" class="headerlink" title="Lambda表达式与被捕获的变量"></a>Lambda表达式与被捕获的变量</h5><p>·使用Lambda表达式可以很简单的给Thread传递参数。但是线程开始后，可能会不小心修改了被捕获的变量，这要多加注意。(例子captured )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0;i&lt;10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        new Thread(()=&gt; Console.Write(i)).Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//i 在循环的整个生命周期内指向的是同一个内存地址</span><br><span class="line">//每个线程对于Console.WriteLine()的调用都会在它运行的时候对它进行修改</span><br></pre></td></tr></table></figure>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>创建线程时在作用范围内的 tryl/catch/finally 块，在线程开始执行后就与线程无关了。在WPF、WinForm里，可以订阅全局异常处理事件:<br>    Application.DispatcherUnhandledException<br>    Application.ThreadException<br>    ·在通过消息循环调用的程序的任何部分发生未处理的异常（这相当于应用程序处于活动状态时在主线程上运行的所有代码)后，将触发这些异常。<br>    ·但是非U线程上的未处理异常，并不会触发它。<br>而任何线程有任何未处理的异常都会触发AppDomain.CurrentDomain.UnhandledException</p>
<h5 id="前台和后台线程"><a href="#前台和后台线程" class="headerlink" title="前台和后台线程"></a>前台和后台线程</h5><p>默认情况下，手动创建的线程就是前台线程。<br>只要有前台线程在运行，那么应用程序就会一直处于活动状态。<br>但是后台线程不行。<br>一旦所有的前台线程停止，那么应用程序就停止了。<br>任何的后台线程也会突然终止。<br>注意：线程的前台、后台状态与它的优先级无关（所分配的执行时间）。</p>
<p>可以通过IsBackground属性判断是否是后台线程。<br>进程以这种形式终止的时候，后台线程执行栈中的finally块就不会被执行了。<br>如果想让它执行，可以在退出程序时使用Join来等待后台线程（如果是自己创建的线程），或者使用signal construct</p>
<p>应用程序无法正常退出的原因是因为还有活跃的前台线程。</p>
<h5 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h5><p>线程的优先级决定了相对于操作系统中的其他活跃线程所占的执行时间。<br>优先级分为：enmu ThreadPriority{Lowest,BelowNormal,Normal,AboveNormal,Highest}</p>
<h5 id="提升线程优先级"><a href="#提升线程优先级" class="headerlink" title="提升线程优先级"></a>提升线程优先级</h5><p>提升线程优先级的时候需特别注意，因为它可能“饿死”其它线程。<br>如果想让某线程(Thread）的优先级比其它进程(Process）中的线程(Thread)高，那就必须提升进程(Process)的优先级<br>·使用System.Diagnostics下的Process类。ProcessPriorityClass是枚举类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using (Process p = Process.GetCurrentProcess()) p.PriorityClass = ProcessPriorityClass.High;</span><br></pre></td></tr></table></figure>
<p>这可以很好地用于只做少量工作且需要较低延迟的非U进程。<br>对于需要大量计算的应用程序（尤其是有U的应用程序），提高进程优先级可能会使其他进程饿死，从而降低整个计算机的速度。</p>
<h5 id="信号signaling"><a href="#信号signaling" class="headerlink" title="信号signaling"></a>信号signaling</h5><p>有时，你需要让某线程一直处于等待的状态，直至接收到其它线程发来的通知。这就叫做signaling(发送信号) 。<br>最简单的信号结构就是ManualResetEvent。<br>调用它上面的 WaitOne方法会阻塞当前的线程，直到另一个线程通过调用Set方法来开启信号。<br><img src="/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/4.png"><br>周用完Set之后，信号会于“打开”的状态。可以通过调用Reset方法将其再次关闭。</p>
<h5 id="富客户端应用程序的线程"><a href="#富客户端应用程序的线程" class="headerlink" title="富客户端应用程序的线程"></a>富客户端应用程序的线程</h5><p>在WPF，UWP，WinForm等类型的程序种，如果在主线程执行耗时的操作，就会导致整个程序无响应。因为主线程同时还需要处理消息循环，而渲染和鼠标键盘事件处理等工作都是消息循环来执行的。<br>针对这种耗时的操作，一种流行的做法是启用一个worker线程。<br>    · 执行完操作后，再更新到UI<br>富客户端应用的线程模型通常是:<br>    · UI元素和控件只能从创建它们的线程来进行访问（(通常是主U线程)<br>    · 当想从 worker线程更新UI的时候，你必须把请求交给U线程<br>比较底层的实现是：<br>    WPF，在元素的Dispatcher对象上调用BeginInvoke或Invoke。<br>    WinForm，调用空间的 BeginInvoke 或 Invoke。<br>    UWP，调用Dispatcher 对象上的 RunAsync或 Invoke。<br>所有这些方法都接收一个委托。<br>BeginInvoke 或 RunAsync通过将委托排队到U线程的消息队列来执行工作。<br>Invoke执行相同的操作，但随后会进行阻塞，直到U线程读取并处理消息。<br>    ·因此,Invoke 允许您从方法中获取返回值。<br>    ·如果不需要返回值，BeginInvoke/RunAsync更可取，因为它们不会阻塞调用方，也不会引入死锁的苛能性<br><img src="/2021/12/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/5.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zh7791/p/9951478.html">C# async/await异步编程深入理解</a><br><a target="_blank" rel="noopener" href="http://siyouku.cn/article/6819.html">C#你应该知道的四种异步方式</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/" rel="tag"># 进程线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/09/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E5%85%B73/" rel="prev" title="初始化工具3">
      <i class="fa fa-chevron-left"></i> 初始化工具3
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/10/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E5%85%B74/" rel="next" title="初始化工具4">
      初始化工具4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">进程与线程学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Process%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">Process类的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">1.1.1.</span> <span class="nav-text">进程的基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">多线程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="nav-number">1.2.</span> <span class="nav-text">补充知识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7"><span class="nav-number">1.2.1.</span> <span class="nav-text">线程的一些属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Join-and-Sleep"><span class="nav-number">1.2.2.</span> <span class="nav-text">Join and Sleep</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E"><span class="nav-number">1.2.3.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadState"><span class="nav-number">1.2.4.</span> <span class="nav-text">ThreadState</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Unblocking"><span class="nav-number">1.2.5.</span> <span class="nav-text">Unblocking</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I-O-bound-%E5%92%8CComputer-bound-%E6%88%96-CPU-Bound"><span class="nav-number">1.2.6.</span> <span class="nav-text">I&#x2F;O-bound 和Computer-bound(或 CPU-Bound)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E-%E5%92%8C-%E5%BF%99%E7%AD%89%E5%BE%85%EF%BC%88%E8%87%AA%E6%97%8B%EF%BC%89"><span class="nav-number">1.2.7.</span> <span class="nav-text">阻塞 和 忙等待（自旋）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#IO-bound%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%A4%E7%A7%8D"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">IO-bound操作的工作方式有两种:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8%E5%BF%99%E7%AD%89%E5%BE%85%E5%92%8C%E9%98%BB%E5%A1%9E%E6%96%B9%E9%9D%A2%E6%9C%89%E4%B8%80%E4%BA%9B%E7%BB%86%E5%BE%AE%E5%B7%AE%E5%88%AB%E3%80%82"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">在忙等待和阻塞方面有一些细微差别。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0local%E7%8A%B6%E6%80%81%E5%92%8C%E5%85%B1%E4%BA%ABshare%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.8.</span> <span class="nav-text">本地local状态和共享share状态</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Local%E6%9C%AC%E5%9C%B0%E7%8B%AC%E7%AB%8B"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">Local本地独立</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Shared%E5%85%B1%E4%BA%AB"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">Shared共享</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.2.9.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E5%AE%9A%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.2.10.</span> <span class="nav-text">锁定与线程安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%91%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.11.</span> <span class="nav-text">向线程传递参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%A2%AB%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.12.</span> <span class="nav-text">Lambda表达式与被捕获的变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.2.13.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E5%8F%B0%E5%92%8C%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.14.</span> <span class="nav-text">前台和后台线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.2.15.</span> <span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E5%8D%87%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.2.16.</span> <span class="nav-text">提升线程优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7signaling"><span class="nav-number">1.2.17.</span> <span class="nav-text">信号signaling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.18.</span> <span class="nav-text">富客户端应用程序的线程</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sandy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sandy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
